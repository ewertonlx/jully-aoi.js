"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseChatInputSubCommandGroupOptions = exports.parseChatInputSubCommandOptions = exports.parseChatInputNumberOptions = exports.parseChatInputBooleanOptions = exports.parseChatInputChannelOptions = exports.parseChatInputUserRoleMentionableOptions = exports.parseChatInputStringOptions = exports.parseChatInputChoice = exports.parseMessage = exports.parseExtraOptions = exports.parseOptions = exports.parseFiles = exports.parseStickers = exports.parseReactions = exports.parseComponents = exports.parseEmbed = void 0;
const utils_1 = require("./utils");
const discord_js_1 = require("discord.js");
function parseEmbed(embedBlock) {
    const res = {
        type: "embed",
        data: {
            description: " ",
            fields: [],
        },
    };
    for (let child of embedBlock.children) {
        let [name, ...values] = child.splits.map(utils_1.removeEscapesAndTrim);
        name = name.trim();
        if (name === "title") {
            res.data.title = values.join(":").trim().replaceAll("#COLON#", ":");
        }
        if (name === "description") {
            res.data.description = values
                .join(":")
                .trim()
                .replaceAll("#COLON#", ":");
        }
        if (name === "url") {
            res.data.url = values.join(":").trim().replaceAll("#COLON#", ":");
        }
        if (name === "color") {
            res.data.color = (0, discord_js_1.resolveColor)((values.join(":").trim().replaceAll("#COLON#", ":")));
        }
        if (name === "timestamp") {
            let timestamp = values.join(":").trim().replaceAll("#COLON#", ":");
            console.log(timestamp);
            let parsedTimestamp = timestamp == "" ? Date.now() : Number(timestamp);
            res.data.timestamp = new Date(parsedTimestamp).toISOString();
        }
        if (name === "footer") {
            const potentialIcon = values.pop()?.trim();
            if (potentialIcon?.startsWith("http://") ||
                potentialIcon?.startsWith("attachment://") ||
                potentialIcon?.startsWith("https://") ||
                potentialIcon?.startsWith("//")) {
                res.data.footer = {
                    text: values.join(":").trim().replaceAll("#COLON#", ":"),
                    icon_url: potentialIcon.trim().replaceAll("#COLON#", ":"),
                };
            }
            else {
                res.data.footer = {
                    text: `${values.join(":").trim().replaceAll("#COLON#", ":") !==
                        ""
                        ? `${values
                            .join(":")
                            .trim()
                            .replaceAll("#COLON#", ":")}:`
                        : ""}${potentialIcon}`
                        .trim()
                        .replaceAll("#COLON#", ":"),
                };
            }
        }
        if (name === "image") {
            res.data.image = {
                url: values.join(":").trim().replaceAll("#COLON#", ":"),
            };
        }
        if (name === "thumbnail") {
            res.data.thumbnail = {
                url: values.join(":").trim().replaceAll("#COLON#", ":"),
            };
        }
        if (name === "author") {
            if (values[values.length - 1]?.startsWith("http") ||
                (values.length > 2 &&
                    values[values.length - 2]?.startsWith("http"))) {
                const potentialIcon = values.pop()?.trim();
                res.data.author = {
                    name: values.join(":").trim().replaceAll("#COLON#", ":"),
                    icon_url: potentialIcon?.trim().replaceAll("#COLON#", ":"),
                };
            }
            else {
                res.data.author = {
                    name: values.join(":").trim().replaceAll("#COLON#", ":"),
                };
            }
        }
        if (name === "authorURL") {
            if (res.data.author) {
                res.data.author.url = values
                    .join(":")
                    .trim()
                    .replaceAll("#COLON#", ":");
            }
        }
        if (name === "field") {
            if (["yes", "no", "true", "false"].includes(values[values.length - 1]?.trim())) {
                const inline = values.pop()?.trim() === "yes";
                const name = values.shift()?.trim().replaceAll("#COLON#", ":") ?? " ";
                const value = values
                    .join(":")
                    .trim()
                    .replaceAll("#COLON#", ":");
                const field = { name, value, inline };
                res.data.fields.push(field);
            }
            else {
                const name = values.shift()?.trim().replaceAll("#COLON#", ":") ?? " ";
                const value = values
                    .join(":")
                    .trim()
                    .replaceAll("#COLON#", ":");
                const field = { name, value };
                res.data.fields.push(field);
            }
        }
    }
    return res;
}
exports.parseEmbed = parseEmbed;
function parseComponents(input) {
    const res = {
        type: 1,
        components: [],
    };
    for (let child of input.children) {
        let [name, ...values] = child.splits.map(utils_1.removeEscapesAndTrim);
        name = name.trim();
        if (name === "button") {
            const button = {
                type: 2,
                style: 1,
                label: "",
            };
            const label = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const style = values.shift()?.trim();
            const customIdorUrl = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const disabled = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
            const emoji = values.shift()?.trim().replaceAll("#COLON#", ":");
            let parsedEmoji = undefined;
            if (emoji) {
                let [animated, name, id] = emoji.split(":");
                if (!name && !id) {
                    name = animated;
                    id = "";
                    animated = "";
                }
                const isAnimated = animated.replace("<", "") === "a";
                id = id.replace(">", "");
                parsedEmoji = {
                    name: name,
                    id: id === "" ? undefined : id,
                    animated: isAnimated,
                };
            }
            const parsedStyle = ((!isNaN(Number(style)) ? Number(style) : utils_1.ButtonStyles[style]));
            button.label = label;
            button.style = parsedStyle;
            button.emoji = parsedEmoji;
            button.disabled = disabled;
            if (parsedStyle === 5) {
                button.url = customIdorUrl;
            }
            else {
                button.custom_id = customIdorUrl;
            }
            res.components.push(button);
        }
        else if (name === "stringInput") {
            const menu = {
                custom_id: "",
                type: 3,
                placeholder: "",
                options: [],
            };
            const customId = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const placeholder = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const minValues = Number(values.shift()?.trim());
            const maxValues = Number(values.shift()?.trim());
            const disabled = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
            const options = [];
            for (const subchild of child.children) {
                let [subname, ...subvalues] = subchild.splits.map(utils_1.removeEscapesAndTrim);
                subname = subname.trim();
                if (subname === "option") {
                    const label = (subvalues.shift()?.trim().replaceAll("#COLON#", ":"));
                    const value = (subvalues.shift()?.trim().replaceAll("#COLON#", ":"));
                    const description = (subvalues.shift()?.trim().replaceAll("#COLON#", ":"));
                    const defaultSelected = ["yes", "true"].includes(subvalues.shift()?.trim() ?? "false");
                    const emoji = (subvalues.shift()?.trim().replaceAll("#COLON#", ":"));
                    let parsedEmoji = undefined;
                    if (emoji) {
                        let [animated, name, id] = emoji.split(":");
                        if (!name && !id) {
                            name = animated;
                            id = "";
                            animated = "";
                        }
                        const isAnimated = animated.replace("<", "") === "a";
                        id = id.replace(">", "");
                        parsedEmoji = {
                            name,
                            id: id === "" ? undefined : id,
                            animated: isAnimated,
                        };
                    }
                    options.push({
                        label,
                        value,
                        description,
                        emoji: parsedEmoji,
                        default: defaultSelected,
                    });
                }
            }
            menu.custom_id = customId;
            menu.placeholder = placeholder;
            menu.min_values = minValues;
            menu.max_values = maxValues;
            menu.disabled = disabled;
            menu.options = options;
            res.components.push(menu);
        }
        else if (name === "userInput") {
            const userInput = {
                custom_id: "",
                type: 5,
                placeholder: "",
            };
            const customId = (values.shift()?.trim().replaceAll("#COLON#", ":")), placeholder = (values.shift()?.trim().replaceAll("#COLON#", ":")), min_values = Number(values.shift()?.trim()), max_values = Number(values.shift()?.trim()), disabled = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
            userInput.custom_id = customId;
            userInput.placeholder = placeholder;
            userInput.min_values = min_values;
            userInput.max_values = max_values;
            userInput.disabled = disabled;
            res.components.push(userInput);
        }
        else if (name === "roleInput") {
            const roleInput = {
                custom_id: "",
                type: 6,
                placeholder: "",
            };
            const customId = (values.shift()?.trim().replaceAll("#COLON#", ":")), placeholder = (values.shift()?.trim().replaceAll("#COLON#", ":")), min_values = Number(values.shift()?.trim()), max_values = Number(values.shift()?.trim()), disabled = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
            roleInput.custom_id = customId;
            roleInput.placeholder = placeholder;
            roleInput.min_values = min_values;
            roleInput.max_values = max_values;
            roleInput.disabled = disabled;
            res.components.push(roleInput);
        }
        else if (name === "mentionInput") {
            const menu = {
                custom_id: "",
                type: 7,
                placeholder: "",
            };
            const customId = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const placeholder = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const min_values = Number(values.shift()?.trim());
            const max_values = Number(values.shift()?.trim());
            const disabled = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
            menu.custom_id = customId;
            menu.placeholder = placeholder;
            menu.min_values = min_values;
            menu.max_values = max_values;
            menu.disabled = disabled;
            res.components.push(menu);
        }
        else if (name === "channelInput") {
            const menu = {
                custom_id: "",
                type: 8,
                placeholder: "",
                channel_types: [],
            };
            const customId = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const placeholder = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const min_values = Number(values.shift()?.trim());
            const max_values = Number(values.shift()?.trim());
            const disabled = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
            menu.custom_id = customId;
            menu.placeholder = placeholder;
            menu.min_values = min_values;
            menu.max_values = max_values;
            menu.disabled = disabled;
            const channelTypes = [];
            for (const subchild of child.children) {
                let [subname, ...subvalues] = subchild.splits.map(utils_1.removeEscapesAndTrim);
                subname = subname.trim();
                if (subname === "channelType") {
                    const type = subvalues[0]?.trim();
                    const parsedType = !isNaN(Number(type))
                        ? Number(type)
                        : utils_1.ChannelTypes[type];
                    channelTypes.push(type);
                }
            }
            menu.channel_types = channelTypes;
            res.components.push(menu);
        }
        else if (name === "textInput") {
            const input = {
                custom_id: "",
                type: 4,
                label: "",
                style: 1,
            };
            const label = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const style = values.shift()?.trim();
            const customId = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const parsedStyle = ((!isNaN(Number(style)) ? Number(style) : utils_1.TextInputStyles[style]));
            const placeholder = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const required = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
            const value = (values.shift()?.trim().replaceAll("#COLON#", ":"));
            const min_length = Number(values.shift()?.trim()) ?? 1;
            const max_length = Number(values.shift()?.trim()) ?? 1;
            input.custom_id = customId;
            input.label = label;
            input.style = parsedStyle;
            input.placeholder = placeholder;
            input.required = required;
            input.value = !value ? undefined : value;
            input.min_length = min_length;
            input.max_length = max_length;
            res.components.push(input);
        }
    }
    return res;
}
exports.parseComponents = parseComponents;
function parseReactions(input) {
    const reactions = [];
    const [_, ...values] = input.splits.map(utils_1.removeEscapesAndTrim);
    let i = 0;
    while (i < values.length) {
        const v = values[i]?.trim();
        let reaction = "";
        if (v === "<" || v === "<a") {
            reaction += v + ":" + values[i + 1] + ":" + values[i + 2];
            reactions.push(reaction?.trim());
            i += 3;
        }
        else {
            reactions.push(v);
            i++;
        }
    }
    return reactions;
}
exports.parseReactions = parseReactions;
function parseStickers(input) {
    const [_, ...values] = input.splits.map(utils_1.removeEscapesAndTrim);
    return values;
}
exports.parseStickers = parseStickers;
function parseFiles(input) {
    let [name, ...values] = input.splits.map(utils_1.removeEscapesAndTrim);
    name = name.trim();
    if (name === "file") {
        const name = values.shift()?.trim();
        return new discord_js_1.AttachmentBuilder(Buffer.from(values.join(":")?.trim()), {
            name,
        });
    }
    else {
        const name = values.shift()?.trim();
        return new discord_js_1.AttachmentBuilder(values.join(":")?.trim(), { name });
    }
}
exports.parseFiles = parseFiles;
function parseOptions(input) {
    const options = {
        tts: false,
        message_reference: undefined,
        allowed_mentions: {
            replied_user: false,
        },
    };
    for (const child of input.children) {
        let [name, ...values] = child.splits.map(utils_1.removeEscapesAndTrim);
        name = name.trim();
        if (name === "tts") {
            options.tts = true;
        }
        else if (name === "reply") {
            options.message_reference = {
                message_id: values[0]?.trim(),
            };
            options.allowed_mentions.replied_user = ["yes", "true"].includes(values[1] ?? "false");
        }
        else if (name === "allowedMentions") {
            for (const subchild of child.children) {
                let [subname, ...subvalues] = subchild.splits.map(utils_1.removeEscapesAndTrim);
                subname = subname.trim();
                if (subname === "parse") {
                    options.allowed_mentions.parse = subvalues;
                }
                else if (subname === "roles") {
                    options.allowed_mentions.roles = subvalues;
                }
                else if (subname === "users") {
                    options.allowed_mentions.users = subvalues;
                }
            }
        }
        else if (name === "fetchReply") {
            options.fetchReply = true;
        }
        else if (name === "ephemeral") {
            options.ephemeral = true;
        }
    }
    return options;
}
exports.parseOptions = parseOptions;
function parseExtraOptions(input) {
    const options = {
        interaction: false,
        reactions: [],
        edits: {
            time: 0,
            messages: [],
        },
        deleteIn: 0,
        deleteCommand: false,
    };
    for (const child of input.children) {
        let [name, ...values] = child.splits.map(utils_1.removeEscapesAndTrim);
        name = name.trim();
        if (name === "interaction") {
            options.interaction = true;
        }
        else if (name === "reactions") {
            options.reactions = parseReactions(child);
        }
        else if (name === "edits") {
            const [time, ...msgs] = values;
            options.edits.time = time;
            for (const msg of child.children) {
                options.edits.messages.push(parseMessage(msg));
            }
        }
        else if (name === "delete") {
            options.deleteIn = values[0];
        }
        else if (name === "deleteCommand") {
            options.deleteCommand = true;
        }
    }
    return options;
}
exports.parseExtraOptions = parseExtraOptions;
function parseMessage(ast) {
    const messageData = {
        tts: false,
        embeds: [],
        components: [],
        reply: undefined,
    };
    let content = ast.content;
    for (const child of ast.children) {
        content = content.replace(child.name, "");
        let [name, _] = child.splits.map(utils_1.removeEscapesAndTrim);
        name = name.trim();
        if (name === "newEmbed") {
            messageData.embeds?.push(parseEmbed(child).data);
        }
        else if (name === "actionRow") {
            messageData.components?.push(parseComponents(child));
        }
        else if (name === "options") {
            const options = parseOptions(child);
            messageData["tts"] = options.tts;
            messageData.allowedMentions = options.allowed_mentions;
            messageData.reply = options.message_reference?.message_id ? {
                messageReference: options.message_reference?.message_id,
            } : undefined;
            // @ts-ignore
            messageData.fetchReply = options.fetchReply;
            // @ts-ignore
            messageData.ephemeral = options.ephemeral;
        }
        else if (name === "stickers") {
            messageData.stickers = parseStickers(child);
        }
        else if (name === "file" || name === "attachment") {
            if (!messageData.files)
                messageData.files = [];
            messageData.files?.push(parseFiles(child));
        }
    }
    messageData.content = content?.trim() === "" ? " " : content.trim();
    return messageData;
}
exports.parseMessage = parseMessage;
function parseChatInputChoice(ast) {
    const parent = ast.parent;
    let type;
    if (parent?.splits[0] === "string")
        type = "string";
    else
        type = "number";
    const choice = {
        name: "",
        value: "",
    };
    const [_, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    choice.name = values.shift()?.trim() ?? "";
    choice.value =
        type === "string"
            ? values.join(":")?.trim() ?? ""
            : parseInt(values.join(":")?.trim() ?? "0");
    for (const child of ast.children) {
        let [name, ...values] = child.splits.map(utils_1.removeEscapesAndTrim);
        name = name.trim();
        if (name === "locale") {
            if (!choice.nameLocalizations)
                choice.nameLocalizations = {};
            const locale = values.shift()?.trim();
            choice.nameLocalizations[locale] = values.join(":")?.trim() ?? "";
        }
    }
    // @ts-ignore
    return choice;
}
exports.parseChatInputChoice = parseChatInputChoice;
function parseChatInputStringOptions(ast) {
    const options = {
        type: 3,
        name: "",
        description: "",
    };
    const [_, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    options.name = values.shift()?.trim();
    options.description = values.shift()?.trim();
    options.required = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
    // @ts-ignore
    options.autocomplete = values.shift()?.trim() === "yes";
    options.minLength = parseInt(values.shift()?.trim() ?? "0");
    options.maxLength = parseInt(values.shift()?.trim() ?? "1");
    for (const child of ast.children) {
        const [name, ...value] = child.splits.map(utils_1.removeEscapesAndTrim);
        if (name === "choice") {
            if (!options.choices)
                options.choices = [];
            options.choices.push(parseChatInputChoice(child));
        }
        else if (name === "locale") {
            const childname = child.name;
            const pos = values.findIndex((x) => x.includes(childname));
            if (pos === 7) {
                if (!options.nameLocalizations)
                    options.nameLocalizations = {};
                const locale = value.shift()?.trim();
                options.nameLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
            else if (pos === 8) {
                if (!options.descriptionLocalizations)
                    options.descriptionLocalizations = {};
                const locale = value.shift()?.trim();
                options.descriptionLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
        }
    }
    return options;
}
exports.parseChatInputStringOptions = parseChatInputStringOptions;
function parseChatInputUserRoleMentionableOptions(ast) {
    const [name, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    const options = {
        type: name === "user" ? 6 : name === "role" ? 8 : 9,
        name: "",
        description: "",
    };
    options.name = values.shift()?.trim();
    options.description = values.shift()?.trim();
    options.required = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
    for (const child of ast.children) {
        const [name, ...value] = child.splits.map(utils_1.removeEscapesAndTrim);
        if (name === "locale") {
            const childname = child.name;
            const pos = values.findIndex((x) => x.includes(childname));
            if (pos === 3) {
                if (!options.nameLocalizations)
                    options.nameLocalizations = {};
                const locale = value.shift()?.trim();
                options.nameLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
            else if (pos === 4) {
                if (!options.descriptionLocalizations)
                    options.descriptionLocalizations = {};
                const locale = value.shift()?.trim();
                options.descriptionLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
        }
    }
    return options;
}
exports.parseChatInputUserRoleMentionableOptions = parseChatInputUserRoleMentionableOptions;
function parseChatInputChannelOptions(ast) {
    const [_, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    const options = {
        type: 7,
        name: "",
        description: "",
    };
    options.name = values.shift()?.trim();
    options.description = values.shift()?.trim();
    options.required = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
    for (const child of ast.children) {
        const [name, ...value] = child.splits.map(utils_1.removeEscapesAndTrim);
        if (name === "type") {
            options.channelTypes = value.map((x) => !isNaN(parseInt(x))
                ? parseInt(x)
                : discord_js_1.ChannelType[x]);
        }
        if (name === "locale") {
            const childname = child.name;
            const pos = values.findIndex((x) => x.includes(childname));
            if (pos === 4) {
                if (!options.nameLocalizations)
                    options.nameLocalizations = {};
                const locale = value.shift()?.trim();
                options.nameLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
            else if (pos === 5) {
                if (!options.descriptionLocalizations)
                    options.descriptionLocalizations = {};
                const locale = value.shift()?.trim();
                options.descriptionLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
        }
    }
    return options;
}
exports.parseChatInputChannelOptions = parseChatInputChannelOptions;
function parseChatInputBooleanOptions(ast) {
    const [_, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    const options = {
        type: 5,
        name: "",
        description: "",
    };
    options.name = values.shift()?.trim();
    options.description = values.shift()?.trim();
    options.required = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
    for (const child of ast.children) {
        const [name, ...value] = child.splits.map(utils_1.removeEscapesAndTrim);
        if (name === "locale") {
            const childname = child.name;
            const pos = values.findIndex((x) => x.includes(childname));
            if (pos === 3) {
                if (!options.nameLocalizations)
                    options.nameLocalizations = {};
                const locale = value.shift()?.trim();
                options.nameLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
            else if (pos === 4) {
                if (!options.descriptionLocalizations)
                    options.descriptionLocalizations = {};
                const locale = value.shift()?.trim();
                options.descriptionLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
        }
    }
    return options;
}
exports.parseChatInputBooleanOptions = parseChatInputBooleanOptions;
function parseChatInputNumberOptions(ast) {
    const [name, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    const options = {
        type: name === "integer" ? 4 : 10,
        name: "",
        description: "",
    };
    options.name = values.shift()?.trim();
    options.description = values.shift()?.trim();
    options.required = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
    // @ts-ignore
    options.autocomplete = ["yes", "true"].includes(values.shift()?.trim() ?? "false");
    const min = values.shift()?.trim();
    const max = values.shift()?.trim();
    options.minValue = min ? parseInt(min) : undefined;
    options.maxValue = max ? parseInt(max) : undefined;
    for (const child of ast.children) {
        const [name, ...value] = child.splits.map(utils_1.removeEscapesAndTrim);
        if (name === "choice") {
            if (!options.choices)
                options.choices = [];
            options.choices.push(parseChatInputChoice(child));
        }
        else if (name === "locale") {
            const childname = child.name;
            const pos = values.findIndex((x) => x.includes(childname));
            if (pos === 6) {
                if (!options.nameLocalizations)
                    options.nameLocalizations = {};
                const locale = value.shift()?.trim();
                options.nameLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
            else if (pos === 7) {
                if (!options.descriptionLocalizations)
                    options.descriptionLocalizations = {};
                const locale = value.shift()?.trim();
                options.descriptionLocalizations[locale] =
                    value.join(":")?.trim() ?? "";
            }
        }
    }
    return options;
}
exports.parseChatInputNumberOptions = parseChatInputNumberOptions;
function parseChatInputSubCommandOptions(ast) {
    const [_, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    const options = {
        type: 1,
        name: "",
        description: "",
        options: [],
    };
    options.name = values.shift()?.trim();
    options.description = values.shift()?.trim();
    for (const child of ast.children) {
        const [name, _] = child.splits.map(utils_1.removeEscapesAndTrim);
        if (!options.options)
            options.options = [];
        if (name === "string") {
            options.options.push(parseChatInputStringOptions(child));
        }
        else if (name === "integer" || "number") {
            options.options.push(parseChatInputNumberOptions(child));
        }
        else if (name === "user" ||
            name === "role" ||
            name === "mentionable") {
            options.options.push(parseChatInputUserRoleMentionableOptions(child));
        }
        else if (name === "channel") {
            options.options.push(parseChatInputChannelOptions(child));
        }
        else if (name === "boolean") {
            options.options.push(parseChatInputBooleanOptions(child));
        }
        else if (name === "subCommand") {
            throw new TypeError("SubCommand cannot be nested in SubCommand");
        }
        else if (name === "subCommandGroup") {
            throw new TypeError("SubCommandGroup cannot be nested in SubCommand");
        }
    }
    return options;
}
exports.parseChatInputSubCommandOptions = parseChatInputSubCommandOptions;
function parseChatInputSubCommandGroupOptions(ast) {
    const [_, ...values] = ast.splits.map(utils_1.removeEscapesAndTrim);
    const options = {
        type: 2,
        name: "",
        description: "",
        options: [],
    };
    options.name = values.shift()?.trim();
    options.description = values.shift()?.trim();
    for (const child of ast.children) {
        if (!options.options)
            options.options = [];
        const [name, _] = child.splits.map(utils_1.removeEscapesAndTrim);
        if (name === "subCommand") {
            options.options.push(parseChatInputSubCommandOptions(child));
        }
        else if (name === "subCommandGroup") {
            throw new TypeError("subCommandGroup cannot be nested in subCommandGroup");
        }
        else {
            throw new TypeError("SubCommandGroup can only have SubCommand");
        }
    }
    return options;
}
exports.parseChatInputSubCommandGroupOptions = parseChatInputSubCommandGroupOptions;
//# sourceMappingURL=components.js.map